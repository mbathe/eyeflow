/**
 * ITriggerDriver — Core abstraction for ALL event sources (spec §7)
 *
 * This is the ONLY interface a new driver must implement.
 * The entire trigger system is built around this contract.
 *
 * ──────────────────────────────────────────────────────────────────
 * HOW TO CREATE A NEW DRIVER
 * ──────────────────────────────────────────────────────────────────
 * 1. Create a class implementing ITriggerDriver
 * 2. Add it to your NestJS module as a multi-provider:
 *
 *    { provide: TRIGGER_DRIVER_TOKEN, useClass: MyDriver, multi: true }
 *
 * 3. Declare `driverId` and `supportedTiers` so Stage 9 and the
 *    TriggerActivationService can route TRIGGER instructions correctly.
 *
 * That's it. No core modification needed.
 * ──────────────────────────────────────────────────────────────────
 *
 * Architecture:
 *   Each driver exposes an RxJS Observable<TriggerEvent>.
 *   The TriggerBusService merges all active driver streams via RxJS merge().
 *   Events are routed to the right workflow execution by workflowId.
 */

import type { Observable } from 'rxjs';
import type { NodeTier } from '../../nodes/interfaces/node-capability.interface';

// ── Injection token ────────────────────────────────────────────────────────

/**
 * NestJS multi-provider injection token.
 * All drivers are discovered via this token at runtime.
 *
 * Usage in module:
 *   { provide: TRIGGER_DRIVER_TOKEN, useClass: MyDriver, multi: true }
 */
export const TRIGGER_DRIVER_TOKEN = 'TRIGGER_DRIVER';

// ── TriggerDriverManifest ──────────────────────────────────────────────────

/**
 * Serialisable metadata a node includes in its NodeRegistrationPayload
 * to advertise custom or node-specific trigger drivers.
 *
 * CENTRAL receives this at node registration and adds the driver to
 * TriggerDriverRegistryService so the compiler can discover it,
 * Stage 9 can assign it, and the UI can present its config schema.
 *
 * A remote node (Rust SVM) that implements a custom driver — e.g. a
 * Modbus RTU poller specific to an industrial controller — simply
 * includes a TriggerDriverManifest in its registration payload.
 * No core modification is needed on CENTRAL.
 *
 * Example (from a Raspberry Pi registration):
 * {
 *   driverId:        'modbus-rtu',
 *   displayName:     'Modbus RTU trigger',
 *   supportedTiers:  ['LINUX'],
 *   requiredProtocols: ['MODBUS'],
 *   configSchema: {
 *     port:     { type: 'string', required: true, example: '/dev/ttyUSB0' },
 *     baudRate: { type: 'number', required: false, default: 9600 },
 *     slaveId:  { type: 'number', required: true },
 *     register: { type: 'number', required: true },
 *   },
 * }
 */
export interface TriggerDriverManifest {
  /** Unique stable driver ID. Matches NodeCapabilities.supportedTriggerDrivers[]. */
  driverId: string;

  /** Human-readable name for the compiler UI. */
  displayName: string;

  /**
   * Node tiers where this driver runs.
   * Used by Stage 9 to filter candidate nodes.
   */
  supportedTiers: string[]; // string instead of NodeTier to keep this interface serialisable

  /**
   * JSON Schema describing the config the driver accepts.
   * Used by the compiler for validation and by the UI to render a config form.
   */
  configSchema: Record<string, any>;

  /**
   * Physical protocols required on the node.
   * Example: ['MODBUS'], ['MQTT'], ['I2C']
   */
  requiredProtocols?: string[];

  /**
   * Optional description shown in the UI.
   */
  description?: string;

  /**
   * The nodeId that declared this manifest.
   * Set by CENTRAL when the registration payload is processed.
   * Not set by the remote node itself.
   */
  sourceNodeId?: string;
}

// ── TriggerEvent ───────────────────────────────────────────────────────────

/**
 * The normalized event emitted by every ITriggerDriver.
 * All driver-specific data is in `payload`.
 */
export interface TriggerEvent {
  /** Unique event ID (generated by the driver) */
  eventId: string;

  /** ISO-8601 timestamp of the original event */
  occurredAt: string;

  /** Driver that produced this event */
  driverId: string;

  /**
   * Workflow ID this trigger is bound to (from TriggerDescriptor.workflowId).
   * Set by the TriggerActivationService when wiring the driver.
   */
  workflowId: string;

  /**
   * Compiled workflow version to execute.
   * The SVM refuses to run if the version is archived or invalid.
   */
  workflowVersion: number;

  /**
   * Raw event payload from the source.
   * For MQTT: the parsed message body.
   * For FS: { event: 'add' | 'change' | 'unlink', path: '...' }
   * For HTTP: { headers, body, query, method }
   * For Cron: { firedAt: ISO, expression }
   * etc.
   */
  payload: Record<string, any>;

  /**
   * Source metadata (optional, for audit trail).
   * For MQTT: { topic, qos, retain }
   * For HTTP: { ip, userAgent }
   */
  source?: Record<string, any>;
}

// ── Driver configuration (from TriggerDescriptor.driverConfig) ────────────

/**
 * Base config all drivers share.
 * Each driver extends this with its own fields.
 */
export interface BaseTriggerConfig {
  /**
   * Debounce in ms — prevent rapid-fire spawning.
   * 0 = no debounce (default for edge-triggered events like GPIO).
   */
  debounceMs?: number;

  /**
   * Max concurrent workflow instances this trigger can launch.
   * Exceeding this drops (or debounces) the event.
   */
  maxConcurrentInstances?: number;

  /**
   * Pre-compiled filter expression string.
   * Evaluated by the driver on the raw payload BEFORE emitting.
   * Example: "payload.pressure > 8.5"
   * Prevents unnecessary workflow instantions for high-frequency sources.
   */
  compiledFilter?: string;
}

// ── ITriggerDriver ─────────────────────────────────────────────────────────

/**
 * Core interface every trigger driver must implement.
 *
 * Lifecycle:
 *   1. TriggerActivationService calls activate(config, workflowId, version)
 *      for each TRIGGER instruction in the deployed LLM-IR.
 *   2. The driver starts its listener and returns a hot Observable.
 *   3. Each event on the observable fires the linked workflow.
 *   4. TriggerActivationService calls deactivate(activationId) on undeploy.
 */
export interface ITriggerDriver {
  /**
   * Unique, stable identifier for this driver.
   * Used in TriggerDescriptor.driverId and NodeCapabilities.supportedTriggerDrivers[].
   *
   * Convention: lowercase, hyphen-separated.
   * Examples: 'mqtt', 'filesystem', 'http-webhook', 'cron', 'imap', 'kafka', 'modbus'
   */
  readonly driverId: string;

  /**
   * Human-readable display name.
   * Shown in the compilation UI when the user picks a trigger.
   */
  readonly displayName: string;

  /**
   * Node tiers where this driver can run.
   * Used by Stage 9 Distribution Planner to assign TRIGGER instructions.
   *
   * Examples:
   *   mqtt:         [CENTRAL, LINUX, MCU]  — runs anywhere
   *   filesystem:   [CENTRAL, LINUX]       — needs an OS
   *   http-webhook: [CENTRAL]              — needs a public HTTP port
   *   cron:         [CENTRAL, LINUX]       — needs a clock + scheduler
   *   imap:         [CENTRAL]              — needs internet + Node.js TLS
   */
  readonly supportedTiers: NodeTier[];

  /**
   * JSON Schema describing the driverConfig shape.
   * Used by the compiler to validate the compiled trigger config.
   * Also shown in the UI as a form for manual configuration.
   */
  readonly configSchema: Record<string, any>;

  /**
   * Optional: required PhysicalProtocol[] for Stage 9 assignment.
   * Example: MqttDriver → ['MQTT']
   * Example: ModbusDriver → ['MODBUS']
   * If absent, no physical protocol constraint is required.
   */
  readonly requiredProtocols?: string[];

  /**
   * Activate this driver for a specific workflow binding.
   *
   * @param activationId  Unique ID for this activation (generate: uuid).
   *                      Used to deactivate precisely without stopping others.
   * @param config        Driver-specific config from TriggerDescriptor.driverConfig.
   * @param workflowId    Workflow to execute when this trigger fires.
   * @param version       Compiled workflow version.
   * @returns             Hot Observable<TriggerEvent> — emits whenever the event fires.
   *                      Completes when deactivate() is called.
   */
  activate(
    activationId: string,
    config: BaseTriggerConfig & Record<string, any>,
    workflowId: string,
    version: number,
  ): Observable<TriggerEvent>;

  /**
   * Deactivate a specific activation.
   * Must close the underlying connection/listener if no other activations remain.
   */
  deactivate(activationId: string): void;

  /**
   * Deactivate ALL activations for this driver.
   * Called at module shutdown.
   */
  deactivateAll(): void;

  /**
   * Health check — returns true if the driver's underlying connection is healthy.
   * Called periodically by TriggerBusService.
   */
  isHealthy(): boolean;
}

// ── Activation record ──────────────────────────────────────────────────────

/**
 * Internal record of an active trigger binding.
 * Maintained by TriggerActivationService.
 */
export interface TriggerActivationRecord {
  activationId: string;
  driverId: string;
  workflowId: string;
  workflowVersion: number;
  nodeId: string;
  /** Driver-specific config (from TriggerDescriptor.driverConfig) */
  config: Record<string, any>;
  activatedAt: Date;
  /** How many times this trigger has fired */
  fireCount: number;
  /** Last time it fired */
  lastFiredAt?: Date;
}

// ── Remote trigger activation payload (for edge nodes) ────────────────────

/**
 * Sent from CENTRAL → remote node via NodesGateway WebSocket
 * when a TRIGGER instruction is assigned to a remote node.
 * The remote Rust SVM uses this to activate its native trigger listener.
 */
export interface RemoteTriggerActivationPayload {
  activationId: string;
  driverId: string;
  driverConfig: Record<string, any>;
  workflowId: string;
  workflowVersion: number;
  compiledFilter?: string;
  /** CENTRAL WebSocket callback URL for event push-back */
  callbackWsChannel: string;
}
